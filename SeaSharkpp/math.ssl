# Defines the factorial of x
def Factorial(x)
{
	result = 1
	i = 2
	while(i <= x)
	{
		result = result * i
		i++
	}
	return result
}

# Defines x raised to the yth power where y is an integer
def intPow(x, y)
{
	result = 1
	i = 0
	while(i < y)
	{
		result = result * x
		i++
	}
	return result
}

# Input is in radians
# Uses the taylor series for sin(x) to approximate it with 5 iterations
def sin(x)
{
	Tao = 2 * PI()
	while(x < 0)
	{
		x += Tao
	}

	while(x > Tao)
	{
		x -= Tao
	}
	multi = 1
	if(x >= PI())
	{
		multi = -1
		x -= PI()
	}
	if(x < PI())
	{
		if(x > PI() / 2)
		{
			x = PI() - x
		}
	}
	result = 0
	i = 0
	while(i < 5)
	{
		oddNum = 2 * i + 1
		diff = intPow(x, oddNum) / Factorial(oddNum)
		if(i % 2 == 0)
		{
			result += diff
		}
		else
		{
			result -= diff
		}
		i++
	}
	return result * multi
}

# Input is in radians
# Uses the taylor series for cos(x) to approximate it with 5 iterations
def cos(x)
{
	Tao = 2 * PI()
	while(x < 0)
	{
		x += Tao
	}
	while(x >= Tao)
	{
		x -= Tao
	}

	if(x > PI())
	{
		x = Tao - x
	}

	result = 1
	i = 1
	while(i < 5)
	{
		num = 2 * i
		diff = intPow(x, num) / Factorial(num)
		if(i % 2 == 0)
		{
			result += diff
		}
		else
		{
			result -= diff
		}
		i++
	}
	return result
}

# Input is in radians
# Ouputs tan(x)
def tan(x)
{
	return sin(x) / cos(x)
}

# returns output in radians
# Uses arcsin(x) taylor series with 20 iterations
def arcsin(x)
{
	result = x
	i = 1
	multiplicand = 1
	num = 1.0

	while(i < 21)
	{
		multiplicand = multiplicand * num / (num + 1)
		oddNum = 2 * i + 1
		result += intPow(x, oddNum) / oddNum * multiplicand
		num += 2
		i++
	}
	return result
}

# returns output in radians
def arccos(x)
{
	return PI() / 2 - arcsin(x)
}

# returns output in radians
# Uses taylor series for arctan(x) with 20 iterations
def arctan(x)
{
	result = 0
	i = 0
	while(i < 20)
	{
		oddNum = 2 * i + 1
		if(i % 2 == 0)
		{
			result += intPow(x, oddNum) / oddNum
		}
		else
		{
			result -= intPow(x, oddNum) / oddNum
		}
		i++
	}
	return result
}

# Returns an approximation of pi
def PI()
{
	return 3.14159265
}

# Input is in degrees
# Converts input to radians
def ToRad(x)
{
	return x * 0.0174532925
}

# Input is in radians
# Converts input to degrees
def ToDegrees(x)
{
	return x * 57.2957795
}

# Input is of type int
# Returns true if input is prime otherwise returns false
def isPrime(x)
{
	if(x == 2)
	{
		return true
	}
	if(x % 2 == 0)
	{
		return false
	}
	if(x == 3)
	{
		return true
	}
	if(x % 3 == 0)
	{
		return false
	}
	i = 3
	while(i * i <= x)
	{
		if(x % i == 0)
		{
			return false
		}
		i++
	}
	return true
}

# Uses the Babylonian Method to approximate the square root of num with 20 iterations
def sqrt(num)
{
	i = 0
	x = 50.0
	while(i < 20)
	{
		x = 0.5 * (x + num / x)
		i++
	}
	return x
}

# Returns length of vector whose components are (x, y, z)
def length(x, y, z)
{
	return sqrt(x * x + y * y + z * z)
}

# Returns a normalized length 3 list with normalized values
def normalize(val)
{
	x = get(val, 0)
	y = get(val, 1)
	z = get(val, 2)
	len = length(x, y, z)
	return [x / len, y / len, z / len]
}

# Returns cross product of vector1 and vector2
def crossProduct(vector1, vector2)
{
	x = get(vector1, 1) * get(vector2, 2) - get(vector1, 2) * get(vector2, 1)
	y = -get(vector1, 0) * get(vector2, 2) + get(vector1, 2) * get(vector2, 0)
	z = get(vector1, 0) * get(vector2, 1) - get(vector1, 1) * get(vector2, 0)

	return [x, y, z]
}

# Returns the smallest number in list
def min(list)
{
	i = 0
	minVal = get(list, 0)
	while(i < size(list))
	{
		if(get(list, i) < minVal)
		{
			minVal = get(list, i)
		}
		i++
	}
	return minVal
}
